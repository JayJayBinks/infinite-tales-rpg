<script lang="ts">
	import { useLocalStorage } from '$lib/state/useLocalStorage.svelte';
	import {
		type Action,
		defaultGameSettings,
		type GameActionState,
		GameAgent,
		type GameSettings,
		type InventoryState,
		type Item,
		type PlayerCharactersGameState
	} from '$lib/ai/agents/gameAgent';
	import { onMount, tick } from 'svelte';
	import { getTextForActionButton, handleError, stringifyPretty } from '$lib/util.svelte';
	import LoadingModal from '$lib/components/LoadingModal.svelte';
	import StoryProgressionWithImage from '$lib/components/StoryProgressionWithImage.svelte';
	import type { RelatedStoryHistory } from '$lib/ai/agents/summaryAgent';
	import { SummaryAgent } from '$lib/ai/agents/summaryAgent';
	import {
		type AiLevelUp,
		type CharacterStats,
		CharacterStatsAgent,
		initialCharacterStatsState,
		type NPCState,
		type SkillsProgression
	} from '$lib/ai/agents/characterStatsAgent';
	import { errorState } from '$lib/state/errorState.svelte';
	import ErrorDialog from '$lib/components/interaction_modals/ErrorModal.svelte';
	import * as gameLogic from './gameLogic';
	import {
		ActionDifficulty,
		applyInventoryUpdate,
		getEmptyCriticalResourceKeys,
		isEnoughResource,
		mustRollDice
	} from './gameLogic';
	import * as combatLogic from './combatLogic';
	import UseSpellsAbilitiesModal from '$lib/components/interaction_modals/UseSpellsAbilitiesModal.svelte';
	import { CombatAgent } from '$lib/ai/agents/combatAgent';
	import { LLMProvider } from '$lib/ai/llmProvider';
	import type { LLMMessage } from '$lib/ai/llm';
	import { initialStoryState, type Story } from '$lib/ai/agents/storyAgent';
	import {
		CharacterAgent,
		type CharacterDescription,
		initialCharacterState
	} from '$lib/ai/agents/characterAgent';
	import DiceRollComponent from '$lib/components/interaction_modals/DiceRollComponent.svelte';
	import UseItemsModal from '$lib/components/interaction_modals/UseItemsModal.svelte';
	import { type Campaign, CampaignAgent, type CampaignChapter } from '$lib/ai/agents/campaignAgent';
	import { ActionAgent } from '$lib/ai/agents/actionAgent';
	import LoadingIcon from '$lib/components/LoadingIcon.svelte';
	import TTSComponent from '$lib/components/TTSComponent.svelte';
	import { applyLevelUp, getXPNeededForLevel } from './levelLogic';
	import LevelUpModal from '$lib/components/interaction_modals/LevelUpModal.svelte';
	import { migrateIfApplicable } from '$lib/state/versionMigration';
	import ImpossibleActionModal from '$lib/components/interaction_modals/ImpossibleActionModal.svelte';
	import GMQuestionModal from '$lib/components/interaction_modals/GMQuestionModal.svelte';
	import SuggestedActionsModal from '$lib/components/interaction_modals/SuggestedActionsModal.svelte';
	import type { AIConfig } from '$lib';
	import ResourcesComponent from '$lib/components/ResourcesComponent.svelte';

	import { initializeMissingResources, refillResourcesFully } from './resourceLogic';
	import {
		advanceChapterIfApplicable,
		getGameMasterNotesForCampaignChapter,
		getNextChapterPrompt
	} from './campaignLogic';
	import { getRelatedHistory } from './memoryLogic';
	import {
		type CharacterChangedInto,
		EventAgent,
		type EventEvaluation,
		initialEventEvaluationState,
	} from '$lib/ai/agents/eventAgent';
	import CharacterChangedConfirmationModal from '$lib/components/interaction_modals/CharacterChangedConfirmationModal.svelte';
	import {
		applyCharacterChange,
		getRequiredSkillProgression,
		getSkillIfApplicable,
		getSkillProgressionForDiceRoll,
		getSkillProgressionForDifficulty
	} from './characterLogic';
	import { getDiceRollPromptAddition } from '$lib/components/interaction_modals/diceRollLogic';
	import { tickCountdownEvents } from './eventLogic';
	// eslint-disable-next-line svelte/valid-compile
	let diceRollDialog, useSpellsAbilitiesModal, useItemsModal, actionsDiv, customActionInput;

	//ai state
	const apiKeyState = useLocalStorage<string>('apiKeyState');
	const temperatureState = useLocalStorage<number>('temperatureState');
	const customSystemInstruction = useLocalStorage<string>('customSystemInstruction');
	const aiLanguage = useLocalStorage<string>('aiLanguage');
	let isAiGeneratingState = $state(false);
	let didAIProcessDiceRollActionState = useLocalStorage<boolean>('didAIProcessDiceRollAction');
	let didAIProcessActionState = useLocalStorage<boolean>('didAIProcessActionState', true);
	let gameAgent: GameAgent,
		summaryAgent: SummaryAgent,
		characterAgent: CharacterAgent,
		characterStatsAgent: CharacterStatsAgent,
		combatAgent: CombatAgent,
		campaignAgent: CampaignAgent,
		actionAgent: ActionAgent,
		eventAgent: EventAgent;

	//game state
	const gameActionsState = useLocalStorage<GameActionState[]>('gameActionsState', []);
	const characterActionsState = useLocalStorage<Action[]>('characterActionsState', []);
	const historyMessagesState = useLocalStorage<LLMMessage[]>('historyMessagesState', []);
	const characterState = useLocalStorage<CharacterDescription>(
		'characterState',
		initialCharacterState
	);
	const characterStatsState = useLocalStorage<CharacterStats>(
		'characterStatsState',
		initialCharacterStatsState
	);
	const skillsProgressionState = useLocalStorage<SkillsProgression>('skillsProgressionState', {});
	let skillsProgressionForCurrentActionState = $state<number | undefined>(undefined);
	const inventoryState = useLocalStorage<InventoryState>('inventoryState', {});
	const storyState = useLocalStorage<Story>('storyState', initialStoryState);
	const relatedStoryHistoryState = useLocalStorage<RelatedStoryHistory>(
		'relatedStoryHistoryState',
		{ relatedDetails: [] }
	);
	const relatedActionHistoryState = useLocalStorage<string[]>('relatedActionHistoryState', []);
	const customMemoriesState = useLocalStorage<string>('customMemoriesState');
	const customGMNotesState = useLocalStorage<string>('customGMNotesState');
	const currentChapterState = useLocalStorage<number>('currentChapterState');
	const campaignState = useLocalStorage<Campaign>('campaignState', {} as Campaign);

	const npcState = useLocalStorage<NPCState>('npcState', {});
	const chosenActionState = useLocalStorage<Action>('chosenActionState', {} as Action);
	const additionalStoryInputState = useLocalStorage<string>('additionalStoryInputState', '');
	const isGameEnded = useLocalStorage<boolean>('isGameEnded', false);
	let playerCharactersGameState: PlayerCharactersGameState = $state({});
	let levelUpState = useLocalStorage<{
		buttonEnabled: boolean;
		dialogOpened: boolean;
		playerName: string;
	}>('levelUpState', {
		buttonEnabled: false,
		dialogOpened: false,
		playerName: ''
	});
	const currentGameActionState: GameActionState = $derived(
		(gameActionsState.value && gameActionsState.value[gameActionsState.value.length - 1]) ||
		({} as GameActionState)
	);
	let actionsTextForTTS: string = $state('');
	//TODO const lastCombatSinceXActions: number = $derived(
	//	gameActionsState.value && (gameActionsState.value.length - (gameActionsState.value.findLastIndex(state => state.is_character_in_combat ) + 1))
	//);
	let customActionReceiver: 'Game Command' | 'Character Action' | 'GM Question' =
		$state('Character Action');
	let customActionImpossibleReasonState: 'not_enough_resource' | 'not_plausible' | undefined =
		$state(undefined);

	let gmQuestionState: string = $state('');
	let itemForSuggestActionsState: (Item & { item_id: string }) | undefined = $state();
	let showEventConfirmationDialog = $state(false);
	const eventEvaluationState = useLocalStorage<EventEvaluation>('eventEvaluationState', initialEventEvaluationState);

	//feature toggles
	const aiConfigState = useLocalStorage<AIConfig>('aiConfigState');
	let useDynamicCombat = useLocalStorage('useDynamicCombat', false);
	let gameSettingsState = useLocalStorage<GameSettings>('gameSettingsState', defaultGameSettings());
	const ttsVoiceState = useLocalStorage<string>('ttsVoice');

	onMount(async () => {
		const llm = LLMProvider.provideLLM(
			{
				temperature: temperatureState.value,
				language: aiLanguage.value,
				apiKey: apiKeyState.value
			},
			aiConfigState.value?.useFallbackLlmState
		);
		gameAgent = new GameAgent(llm);
		characterStatsAgent = new CharacterStatsAgent(llm);
		combatAgent = new CombatAgent(llm);
		summaryAgent = new SummaryAgent(llm);
		campaignAgent = new CampaignAgent(llm);
		actionAgent = new ActionAgent(llm);
		eventAgent = new EventAgent(llm);
		characterAgent = new CharacterAgent(llm);

		characterStatsState.value = migrateIfApplicable(
			'characterStatsState',
			$state.snapshot(characterStatsState.value)
		);

		const currentCharacterName = characterState.value.name;

		// Initialize the player's resource state if it doesn't exist.
		playerCharactersGameState[currentCharacterName] = {
			...$state.snapshot(characterStatsState.value.resources),
			XP: { current_value: 0, max_value: 0, game_ends_when_zero: false }
		};
		if (relatedStoryHistoryState.value.relatedDetails.length === 0) {
			getRelatedHistoryForStory();
		}

		// Start game when not already started
		if (!currentGameActionState?.story) {
			await initializeGame();
		} else {
			await initializeGameFromSavedState();
		}
	});

	async function initializeGameFromSavedState() {
		// Apply previously saved game actions
		//TODO what happens when character transformed, if stat existed before damage/heal will be applied
		gameLogic.applyGameActionStates(
			playerCharactersGameState,
			npcState.value,
			inventoryState.value,
			$state.snapshot(gameActionsState.value)
		);
		const { updatedGameActionsState, updatedPlayerCharactersGameState } =
			initializeMissingResources(
				$state.snapshot(characterStatsState.value.resources),
				$state.snapshot(characterState.value.name),
				$state.snapshot(gameActionsState.value),
				$state.snapshot(playerCharactersGameState)
			);
		gameActionsState.value = updatedGameActionsState;
		playerCharactersGameState = updatedPlayerCharactersGameState;
		tick().then(() => customActionInput.scrollIntoView(false));
		if (characterActionsState.value.length === 0) {
			characterActionsState.value = await actionAgent.generateActions(
				currentGameActionState,
				historyMessagesState.value,
				storyState.value,
				characterState.value,
				characterStatsState.value,
				inventoryState.value,
				customSystemInstruction.value,
				await getRelatedHistory(
					summaryAgent,
					undefined,
					undefined,
					relatedStoryHistoryState.value,
					customMemoriesState.value
				),
				gameSettingsState.value?.aiIntroducesSkills
			);
		}
		renderGameState(currentGameActionState, characterActionsState.value);
		if (!didAIProcessDiceRollActionState.value) {
			openDiceRollDialog();
		}
		checkForLevelUp();
	}

	async function initializeGame() {
		await sendAction({
			characterName: characterState.value.name,
			text: GameAgent.getStartingPrompt()
		});
		if (gameActionsState.value.length === 0) return;
		// Initialize all resources when the game is first started.
		const { updatedGameActionsState, updatedPlayerCharactersGameState } = refillResourcesFully(
			$state.snapshot(characterStatsState.value.resources),
			$state.snapshot(characterState.value.name),
			$state.snapshot(gameActionsState.value),
			$state.snapshot(playerCharactersGameState)
		);
		gameActionsState.value = updatedGameActionsState;
		playerCharactersGameState = updatedPlayerCharactersGameState;
	}

	//TODO applyGameActionState should not be handled here so it can be externally called
	async function getActionPromptForCombat(
		playerAction: Action,
		currentGameActionState: GameActionState,
		npcState: NPCState,
		inventoryState: InventoryState,
		customSystemInstruction: string,
		latestStoryMessages: LLMMessage[],
		storyState: Story,
		playerCharactersGameState: PlayerCharactersGameState,
		combatAgent: CombatAgent
	): Promise<{
		additionalStoryInput: string;
		determinedActionsAndStatsUpdate: ReturnType<typeof combatAgent.generateActionsFromContext>;
	}> {
		// Get details for all NPC targets based on the current game action state.
		const allNpcsDetailsAsList = gameLogic
			.getAllTargetsAsList(currentGameActionState.currently_present_npcs)
			.map((technicalId) => ({
				technicalId,
				...npcState[technicalId]
			}));

		// Compute the determined combat actions and stats update.
		const determinedActionsAndStatsUpdate = await combatAgent.generateActionsFromContext(
			playerAction,
			playerCharactersGameState[characterState.value.name],
			inventoryState,
			allNpcsDetailsAsList,
			customSystemInstruction,
			latestStoryMessages,
			storyState
		);

		// Apply the action state update on the playerCharactersGameState (and related states)
		// by passing a snapshot of the determined update.
		gameLogic.applyGameActionState(
			playerCharactersGameState,
			npcState,
			inventoryState,
			$state.snapshot(determinedActionsAndStatsUpdate)
		);

		// Filter to find the alive NPCs.
		const aliveNPCs = allNpcsDetailsAsList
			.filter((npc) => npc?.resources && npc.resources.current_hp > 0)
			.map((npc) => npc.technicalId);

		// Generate additional story input based on the combat results.
		const additionalStoryInput = CombatAgent.getAdditionalStoryInput(
			determinedActionsAndStatsUpdate.actions,
			[],
			aliveNPCs,
			playerCharactersGameState
		);

		return { additionalStoryInput, determinedActionsAndStatsUpdate };
	}

	const advanceSkillIfApplicable = (skillName: string) => {
		const requiredSkillProgression = getRequiredSkillProgression(
			skillName,
			characterStatsState.value
		);
		if (requiredSkillProgression) {
			if (skillsProgressionState.value[skillName] >= requiredSkillProgression) {
				characterStatsState.value.skills[skillName] += 1;
				skillsProgressionState.value[skillName] = 0;
				gameActionsState.value[gameActionsState.value.length].stats_update.push({
					sourceId: characterState.value.name,
					targetId: characterState.value.name,
					value: { result: skillName },
					type: 'skill_increased'
				});
			}
		} else {
			console.log('No required skill progression found for skill: ' + skillName);
		}
	};

	const addSkillProgression = (skillName: string, skillProgression: number) => {
		if (!skillsProgressionState.value[skillName]) {
			skillsProgressionState.value[skillName] = 0;
		}
		console.log('Adding skill progression for ' + skillName + ': ' + skillProgression);
		skillsProgressionState.value[skillName] += skillProgression;
	};

	function openDiceRollDialog() {
		//TODO showModal can not be used because it hides the dice roll
		didAIProcessDiceRollActionState.value = false;
		diceRollDialog.show();
		diceRollDialog.addEventListener('close', function sendWithManuallyRolled() {
			diceRollDialog.removeEventListener('close', sendWithManuallyRolled);
			const result = diceRollDialog.returnValue;

			const skillName = getSkillIfApplicable(characterStatsState.value, chosenActionState.value);
			if (skillName) {
				skillsProgressionForCurrentActionState = getSkillProgressionForDiceRoll(result);
			}

			additionalStoryInputState.value =
				getDiceRollPromptAddition(result) + '\n' + (additionalStoryInputState.value || '');
			sendAction(chosenActionState.value, false);
		});
	}

	function handleAIError() {
		if (!didAIProcessDiceRollActionState.value) {
			openDiceRollDialog();
		}
	}

	async function handleImpossibleAction(tryAnyway: boolean) {
		if (tryAnyway) {
			if (customActionImpossibleReasonState === 'not_enough_resource') {
				chosenActionState.value = {
					...chosenActionState.value,
					action_difficulty:
						chosenActionState.value.action_difficulty === ActionDifficulty.simple
							? ActionDifficulty.medium
							: chosenActionState.value.action_difficulty,
					dice_roll: {
						modifier: chosenActionState.value.dice_roll!.modifier!,
						modifier_explanation:
							chosenActionState.value.dice_roll!.modifier_explanation! +
							` -3 for trying without enough ${chosenActionState.value.resource_cost?.resource_key?.replaceAll('_', ' ')}`,
						modifier_value:
							Number.parseInt(
								chosenActionState.value.dice_roll?.modifier_value as unknown as string
							) || 0 - 3
					}
				};
			}
			//either not enough resource or impossible, anyway no resource cost
			let costString = 'No resource cost';
			if (chosenActionState.value.resource_cost) {
				chosenActionState.value.resource_cost.cost = 0;
				costString = `\n${chosenActionState.value.resource_cost?.resource_key} cost: 0`;
			}
			additionalStoryInputState.value += costString;
			await sendAction(chosenActionState.value, true);
		}
		customActionInput.value = '';
		customActionImpossibleReasonState = undefined;
	}

	//TODO depends on getActionPromptForCombat
	async function getCombatAndNPCState(
		action: Action,
		isGameEnded: boolean,
		currentGameActionState: GameActionState,
		npcState: NPCState,
		inventoryState: InventoryState,
		customSystemInstruction: string,
		latestStoryMessages: LLMMessage[],
		storyState: Story,
		playerCharactersGameState: PlayerCharactersGameState,
		combatAgent: CombatAgent,
		useDynamicCombat: boolean
	): Promise<{
		additionalStoryInput: string;
		allCombatDeterminedActionsAndStatsUpdate?: ReturnType<
			typeof combatAgent.generateActionsFromContext
		>;
	}> {
		let deadNPCs: string[] = [];
		let additionalStoryInput = '';
		let allCombatDeterminedActionsAndStatsUpdate;
		if (!isGameEnded && currentGameActionState.is_character_in_combat) {
			additionalStoryInput += CombatAgent.getCombatPromptAddition();
			if (useDynamicCombat) {
				const combatObject = await getActionPromptForCombat(
					action,
					currentGameActionState,
					npcState,
					inventoryState,
					customSystemInstruction,
					latestStoryMessages,
					storyState,
					playerCharactersGameState,
					combatAgent
				);
				//dynamic combat already handled the getNPCsHealthStatePrompt
				additionalStoryInput += combatObject.additionalStoryInput;
				allCombatDeterminedActionsAndStatsUpdate = combatObject.determinedActionsAndStatsUpdate;
			}
		}
		deadNPCs = gameLogic.removeDeadNPCs(npcState);
		additionalStoryInput += CombatAgent.getNPCsHealthStatePrompt(deadNPCs);
		return { additionalStoryInput, allCombatDeterminedActionsAndStatsUpdate };
	}

	//TODO sendAction should not be handled here so it can be externally called
	async function checkGameEnded() {
		const emptyResourceKeys = getEmptyCriticalResourceKeys(
			playerCharactersGameState[characterState.value.name]
		);
		if (!isGameEnded.value && emptyResourceKeys.length > 0) {
			isGameEnded.value = true;
			await sendAction({
				characterName: characterState.value.name,
				text: GameAgent.getGameEndedPrompt(emptyResourceKeys)
			});
		}
	}

	function resetStatesAfterActionProcessed() {
		chosenActionState.reset();
		additionalStoryInputState.reset();
		characterActionsState.reset();
		relatedActionHistoryState.reset();
		relatedStoryHistoryState.reset();
		skillsProgressionForCurrentActionState = undefined;
		if (actionsDiv) actionsDiv.innerHTML = '';
		if (customActionInput) customActionInput.value = '';
		didAIProcessDiceRollActionState.value = true;
	}

	function checkForNewNPCs(newState: GameActionState) {
		const newNPCs = gameLogic.getNewNPCs(newState.currently_present_npcs, npcState.value);
		if (newNPCs.length > 0) {
			characterStatsAgent
				.generateNPCStats(
					storyState.value,
					getLatestStoryMessages(),
					newNPCs,
					characterStatsState.value,
					customSystemInstruction.value
				)
				.then((newState: NPCState) => {
					if (newState) {
						combatLogic.addResourceValues(newState);
						npcState.value = { ...npcState.value, ...newState };
						console.log(stringifyPretty(npcState.value));
					}
				});
		}
	}

	function checkForLevelUp() {
		const neededXP = getXPNeededForLevel(characterStatsState.value.level);
		if (
			neededXP &&
			playerCharactersGameState[characterState.value.name]?.XP.current_value >= neededXP
		) {
			levelUpState.value.buttonEnabled = true;
		}
	}

	function updateMessagesHistory(updatedHistoryMessages: Array<LLMMessage>) {
		historyMessagesState.value = updatedHistoryMessages;
	}

	async function addCampaignAdditionalStoryInput(action: Action, additionalStoryInput: string) {
		// If the game is played in campaign mode
		if (campaignState.value?.chapters?.length > 0) {
			//advance the chapter if applicable.
			const { newAdditionalStoryInput, newChapter } = await advanceChapterIfApplicable(
				action,
				additionalStoryInput,
				didAIProcessActionState.value,
				campaignState.value,
				currentChapterState.value,
				currentGameActionState,
				gameActionsState.value,
				campaignAgent,
				historyMessagesState.value
			);
			additionalStoryInput = newAdditionalStoryInput;

			if (newChapter) {
				currentChapterState.value += 1;
				currentGameActionState.currentPlotPoint = 'PLOT_ID: 1';
				const { prompt, updatedStory } = getNextChapterPrompt(
					campaignState.value,
					currentChapterState.value,
					storyState.value
				);
				additionalStoryInput += prompt;
				storyState.value = updatedStory;
			}
		}
		return additionalStoryInput;
	}

	// Helper to prepare additional story input by incorporating combat prompts
	async function prepareAdditionalStoryInput(
		action: Action,
		initialAdditionalStoryInput: string
	): Promise<{
		finalAdditionalStoryInput: string;
		combatAndNPCState: {
			additionalStoryInput: string;
			allCombatDeterminedActionsAndStatsUpdate?: ReturnType<
				typeof combatAgent.generateActionsFromContext
			>;
		};
	}> {
		let additionalStoryInput = initialAdditionalStoryInput || '';

		// Retrieve combat and NPC-related story additions.
		const combatAndNPCState = await getCombatAndNPCState(
			action,
			isGameEnded.value,
			currentGameActionState,
			npcState.value,
			inventoryState.value,
			customSystemInstruction.value,
			getLatestStoryMessages(),
			storyState.value,
			playerCharactersGameState,
			combatAgent,
			useDynamicCombat.value
		);
		// Combine combat-related additional story input.
		additionalStoryInput += combatAndNPCState.additionalStoryInput;

		additionalStoryInput = await addCampaignAdditionalStoryInput(action, additionalStoryInput);

		const gmNotes = getGameMasterNotesForCampaignChapter(
			getCurrentCampaignChapter(),
			currentGameActionState.currentPlotPoint
		);
		if (customGMNotesState.value) {
			gmNotes.unshift(customGMNotesState.value);
		}
		additionalStoryInput += GameAgent.getPromptForGameMasterNotes(gmNotes);

		// Add any extra side effects that should modify the story input.
		additionalStoryInput = gameLogic.addAdditionsFromActionSideeffects(
			action,
			additionalStoryInput
		);

		// Update the store for additional story input.
		additionalStoryInputState.value = additionalStoryInput;

		return { finalAdditionalStoryInput: additionalStoryInput, combatAndNPCState };
	}

	const applyGameEventEvaluation =  (evaluated: EventEvaluation) => {
		const changeInto = evaluated?.character_changed?.changed_into;
		if (changeInto && changeInto !== eventEvaluationState.value.character_changed?.changed_into) {
			evaluated.character_changed.aiProcessingComplete = false;
			eventEvaluationState.value = { ...eventEvaluationState.value, character_changed: evaluated.character_changed };
		}
		const countdown_events = evaluated?.countdown_events;
		if (countdown_events && countdown_events.length > 0) {
			eventEvaluationState.value = { ...eventEvaluationState.value, countdown_events };
		}
		const duration_events = evaluated?.duration_events;
		if (duration_events && duration_events.length > 0) {
			duration_events.filter(e => !eventEvaluationState.value.duration_events.some(e2 => e2.unique_id === e.unique_id))
				.forEach(event => customGMNotesState.value += '\n' + event.consequence);
			eventEvaluationState.value = { ...eventEvaluationState.value, duration_events: [...eventEvaluationState.value.duration_events, ...duration_events] };
		}
		const cancel_events = evaluated?.cancel_events;
		if (cancel_events && cancel_events.length > 0) {
			const countdown_events = eventEvaluationState.value.countdown_events.filter(
				(event) => !cancel_events.includes(event.unique_id)
			);
			const duration_events = eventEvaluationState.value.duration_events.filter(
				(event) => !cancel_events.includes(event.unique_id)
			);
			eventEvaluationState.value = { ...eventEvaluationState.value, countdown_events, duration_events,
				cancel_events: [...eventEvaluationState.value.cancel_events, ...cancel_events] };
		}
	}




	// Helper to process the AI story progression and update game state accordingly.
	async function processStoryProgression(
		action: Action,
		additionalStoryInput: string,
		relatedHistory: string[],
		combatAndNPCState: {
			additionalStoryInput: string;
			allCombatDeterminedActionsAndStatsUpdate?: ReturnType<
				typeof combatAgent.generateActionsFromContext
			>;
		}
	) {
		didAIProcessActionState.value = false;
		const { newState, updatedHistoryMessages } = await gameAgent.generateStoryProgression(
			action,
			additionalStoryInput,
			customSystemInstruction.value,
			historyMessagesState.value,
			storyState.value,
			characterState.value,
			playerCharactersGameState,
			inventoryState.value,
			relatedHistory,
			gameSettingsState.value
		);
		didAIProcessActionState.value = true;

		if (newState?.story) {
			// If combat provided a specific stat update, use it.
			if (combatAndNPCState.allCombatDeterminedActionsAndStatsUpdate) {
				newState.stats_update =
					combatAndNPCState.allCombatDeterminedActionsAndStatsUpdate.stats_update;
				applyInventoryUpdate(inventoryState.value, newState);
			} else {
				// Otherwise, apply the new state to the game state.
				gameLogic.applyGameActionState(
					playerCharactersGameState,
					npcState.value,
					inventoryState.value,
					$state.snapshot(newState)
				);
			}
			console.log('new state', stringifyPretty(newState));
			updateMessagesHistory(updatedHistoryMessages);
			checkForNewNPCs(newState);
			const skillName = getSkillIfApplicable(characterStatsState.value, action);
			if (skillName) {
				//if no dice was rolled, use difficulty
				if (skillsProgressionForCurrentActionState === undefined) {
					const skillProgression = getSkillProgressionForDifficulty(action.action_difficulty);
					addSkillProgression(skillName, skillProgression);
				}
				advanceSkillIfApplicable(skillName);
			}

			resetStatesAfterActionProcessed();

			// Let the summary agent shorten the history, if needed.
			const { newHistory } = await summaryAgent.summarizeStoryIfTooLong(historyMessagesState.value);
			historyMessagesState.value = newHistory;
			// Append the new game state to the game actions.
			gameActionsState.value = [
				...gameActionsState.value,
				{
					...newState,
					id: gameActionsState.value.length
				}
			];
			await checkGameEnded();

			if (!isGameEnded.value) {
				const tickedEvents = tickCountdownEvents(eventEvaluationState.value.countdown_events);
				if (tickedEvents.length > 0) {
					additionalStoryInput += '\n' + tickedEvents.map(e => 'Following event activates now: ' + e.consequence).join('\n');
					eventEvaluationState.value = { ...eventEvaluationState.value,
						countdown_events: eventEvaluationState.value.countdown_events.filter(e => !tickedEvents.includes(e)) };
				}
				getRelatedHistoryForStory();
				eventAgent.evaluateEvents(historyMessagesState.value.slice(-6).map(m => m.content), eventEvaluationState.value)
					.then(applyGameEventEvaluation);
				// Generate the next set of actions.
				actionAgent.generateActions(
					currentGameActionState,
					historyMessagesState.value,
					storyState.value,
					characterState.value,
					characterStatsState.value,
					inventoryState.value,
					customSystemInstruction.value,
					relatedHistory,
					gameSettingsState.value?.aiIntroducesSkills
				)
					.then((actions) => {
						if (actions) {
							console.log(stringifyPretty(actions));
							characterActionsState.value = actions;
							renderGameState(currentGameActionState, actions);
							// Add all skills from action to characterStatsState
							if (gameSettingsState.value?.aiIntroducesSkills) {
								actions.forEach((action: Action) => {
									const skill = getSkillIfApplicable(
										$state.snapshot(characterStatsState.value),
										action
									);
									//TODO skill can be trait sometimes which we dont want?
									if (skill) {
										characterStatsState.value.skills[skill] = 0;
									}
								});
							}
						}
					});
				checkForLevelUp();
			}
		}
	}

	function getRelatedHistoryForStory() {
		summaryAgent
			.retrieveRelatedHistory(currentGameActionState.story, gameActionsState.value, 2)
			.then((relatedHistory) => {
				if (relatedHistory) {
					relatedStoryHistoryState.value = relatedHistory;
				} else {
					relatedStoryHistoryState.reset();
				}
			});
	}

	// Main sendAction function that orchestrates the action processing.
	async function sendAction(action: Action, rollDice = false) {
		try {
			if (rollDice) {
				if (relatedActionHistoryState.value.length === 0) {
					getRelatedHistory(
						summaryAgent,
						action,
						gameActionsState.value,
						$state.snapshot(relatedStoryHistoryState.value),
						$state.snapshot(customMemoriesState.value)
					).then((relatedHistory) => {
						relatedActionHistoryState.value = relatedHistory;
					});
				}
				openDiceRollDialog();
			} else {
				isAiGeneratingState = true;

				// Prepare the additional story input (including combat and chapter info)
				const { finalAdditionalStoryInput, combatAndNPCState } = await prepareAdditionalStoryInput(
					action,
					additionalStoryInputState.value
				);
				if (relatedActionHistoryState.value.length === 0) {
					relatedActionHistoryState.value = await getRelatedHistory(
						summaryAgent,
						action,
						gameActionsState.value,
						$state.snapshot(relatedStoryHistoryState.value),
						$state.snapshot(customMemoriesState.value)
					);
				}
				// Process the AI story progression and update game state
				await processStoryProgression(
					action,
					finalAdditionalStoryInput,
					relatedActionHistoryState.value,
					combatAndNPCState
				);

				isAiGeneratingState = false;
			}
		} catch (e) {
			isAiGeneratingState = false;
			handleError(e as string);
		}
	}

	function renderGameState(state: GameActionState, actions: Array<Action>) {
		if (!isGameEnded.value) {
			actions.forEach((action) =>
				addActionButton(action, state.is_character_in_combat, 'ai-gen-action')
			);
			actionsTextForTTS =
				Array.from(document.querySelectorAll('.ai-gen-action'))
					.map((elm) => elm.textContent || ' ')
					.join(' ') || ' ';
		}
	}

	function levelUpClicked(playerName: string) {
		levelUpState.value.playerName = playerName;
		const level = $state.snapshot(characterStatsState.value.level);
		const xpNeededForLevel = getXPNeededForLevel(level);
		if (!xpNeededForLevel) {
			handleError('Could not calculate XP needed for level up!');
			return;
		}
		const buyLevelUpObject = GameAgent.getLevelUpCostObject(xpNeededForLevel, playerName, level);
		playerCharactersGameState[playerName].XP.current_value -= xpNeededForLevel;
		gameActionsState.value[gameActionsState.value.length - 1].stats_update.push(buyLevelUpObject);
		levelUpState.value.dialogOpened = true;
	}

	function addActionButton(action: Action, is_character_in_combat?: boolean, addClass?: string) {
		if (!actionsDiv) {
			return;
		}
		const button = document.createElement('button');
		button.className = 'btn btn-neutral mb-3 w-full text-md';
		if (addClass) {
			button.className += ' ' + addClass;
		}
		button.textContent = getTextForActionButton(action);
		if (
			!isEnoughResource(
				action,
				playerCharactersGameState[characterState.value.name],
				inventoryState.value
			)
		) {
			button.disabled = true;
		}
		button.addEventListener('click', () => {
			chosenActionState.value = $state.snapshot(action);
			sendAction(
				chosenActionState.value,
				gameLogic.mustRollDice(chosenActionState.value, is_character_in_combat)
			);
		});
		actionsDiv.appendChild(button);
	}

	function getLatestStoryMessages(numOfActions = 2) {
		const historyMessages: LLMMessage[] = historyMessagesState.value.slice(numOfActions * -2);
		return historyMessages.map((message) => {
			try {
				return { ...message, content: JSON.parse(message.content).story };
				// eslint-disable-next-line @typescript-eslint/no-unused-vars
			} catch (e) {
				return message;
			}
		});
	}

	const onItemUseChosen = async (item: Action & Item & { item_id: string }) => {
		itemForSuggestActionsState = item;
	};

	const onTargetedSpellsOrAbility = async (action: Action, targets: string[]) => {
		isAiGeneratingState = true;
		let targetAddition = '';
		if (targets?.length > 0 && !targets.some((t) => t === undefined)) {
			targetAddition = targets?.length === 0 ? '' : gameLogic.getTargetPromptAddition(targets);
		}
		action.text += targetAddition;
		relatedActionHistoryState.value = await getRelatedHistory(
			summaryAgent,
			action,
			gameActionsState.value,
			$state.snapshot(relatedStoryHistoryState.value),
			$state.snapshot(customMemoriesState.value)
		);
		const difficultyResponse = await actionAgent.generateSingleAction(
			action,
			currentGameActionState,
			getLatestStoryMessages(),
			storyState.value,
			characterState.value,
			characterStatsState.value,
			inventoryState.value,
			customSystemInstruction.value,
			relatedActionHistoryState.value,
			gameSettingsState.value?.aiIntroducesSkills
		);
		if (difficultyResponse) {
			for (const key in difficultyResponse) {
				if (action[key] === undefined) {
					action[key] = difficultyResponse[key];
				}
			}
		}
		action.is_custom_action = true;
		console.log('difficultyResponse', stringifyPretty(action));
		chosenActionState.value = action;
		const abilityAddition =
			'\n If this is a friendly action used on an enemy, play out the effect as described, even though the result may be unintended.' +
			'\n Hostile NPCs stay hostile unless explicitly described otherwise by the actions effect.' +
			'\n Friendly NPCs turn hostile if attacked.';

		additionalStoryInputState.value = targetAddition + abilityAddition + (additionalStoryInputState.value || '');
		await sendAction(
			action,
			gameLogic.mustRollDice(action, currentGameActionState.is_character_in_combat)
		);
		isAiGeneratingState = false;
	};
	const onLevelUpModalClosed = (aiLevelUp: AiLevelUp) => {
		if (aiLevelUp) {
			characterStatsState.value = applyLevelUp(aiLevelUp, characterStatsState.value);
		} else {
			characterStatsState.value = {
				...characterStatsState.value,
				level: characterStatsState.value.level + 1
			};
		}
		levelUpState.reset();
		const { updatedGameActionsState, updatedPlayerCharactersGameState } = refillResourcesFully(
			$state.snapshot(characterStatsState.value.resources),
			$state.snapshot(characterState.value.name),
			$state.snapshot(gameActionsState.value),
			$state.snapshot(playerCharactersGameState)
		);
		gameActionsState.value = updatedGameActionsState;
		playerCharactersGameState = updatedPlayerCharactersGameState;
		checkForLevelUp();
	};

	const onSuggestItemActionClosed = (action?: Action) => {
		if (action) {
			if (action.is_custom_action) {
				generateActionFromCustomInput(action);
			} else {
				chosenActionState.value = $state.snapshot(action);
				sendAction(action, mustRollDice(action, currentGameActionState.is_character_in_combat));
			}
		}
		itemForSuggestActionsState = undefined;
	};

	const getCurrentCampaignChapter = (): CampaignChapter | undefined =>
		campaignState.value?.chapters.find(
			(chapter) => chapter.chapterId === currentChapterState.value
		);

	const generateActionFromCustomInput = async (action: Action) => {
		isAiGeneratingState = true;
		relatedActionHistoryState.value = await getRelatedHistory(
			summaryAgent,
			action,
			gameActionsState.value,
			$state.snapshot(relatedStoryHistoryState.value),
			$state.snapshot(customMemoriesState.value)
		);
		console.log(
			'relatedHistoryDetails',
			stringifyPretty($state.snapshot(relatedStoryHistoryState.value))
		);
		const generatedAction = await actionAgent.generateSingleAction(
			action,
			currentGameActionState,
			historyMessagesState.value,
			storyState.value,
			characterState.value,
			characterStatsState.value,
			inventoryState.value,
			customSystemInstruction.value,
			relatedActionHistoryState.value,
			gameSettingsState.value?.aiIntroducesSkills
		);
		console.log('action', stringifyPretty(generatedAction));
		action = { ...generatedAction, ...action };
		chosenActionState.value = action;
		if (action.is_possible === false) {
			customActionImpossibleReasonState = 'not_plausible';
		} else {
			if (
				!isEnoughResource(
					action,
					playerCharactersGameState[characterState.value.name],
					inventoryState.value
				)
			) {
				customActionImpossibleReasonState = 'not_enough_resource';
			} else {
				customActionImpossibleReasonState = undefined;
				await sendAction(
					action,
					gameLogic.mustRollDice(action, currentGameActionState.is_character_in_combat)
				);
			}
		}
		isAiGeneratingState = false;
	};

	const onCustomActionSubmitted = async () => {
		let action: Action = {
			characterName: characterState.value.name,
			text: customActionInput.value,
			is_custom_action: true
		};
		if (customActionReceiver === 'Character Action') {
			await generateActionFromCustomInput(action);
		}
		if (customActionReceiver === 'GM Question') {
			gmQuestionState = action.text;
		}
		if (customActionReceiver === 'Game Command') {
			additionalStoryInputState.value += '\nsudo: Ignore the rules and play out this action even if it should not be possible!\n' +
				'If this action contradicts the PAST STORY PLOT, adjust the narrative to fit the action.';
			await sendAction(
				action,
				false
			);
		}
	};
	const onGMQuestionClosed = (closedByPlayer: boolean) => {
		if (closedByPlayer) {
			customActionInput.value = '';
		}
		gmQuestionState = '';
	};

	function onDeleteItem(item_id: string): void {
		delete inventoryState.value[item_id];
		if (gameActionsState.value[gameActionsState.value.length - 1].inventory_update) {
			gameActionsState.value[gameActionsState.value.length - 1].inventory_update.push({
				item_id,
				type: 'remove_item'
			});
		}
	}

	function getEventToConfirm(gamEvent: CharacterChangedInto): {
		title: string;
		description: string;
	} {
		return {
			title: 'Character Change: ' + gamEvent.changed_into,
			description: gamEvent.description
		};
	}

	async function confirmEvent(changedInto: CharacterChangedInto, confirmed: boolean) {
		showEventConfirmationDialog = false;
		if (confirmed === undefined) {
			return;
		}
		if (confirmed) {
			isAiGeneratingState = true;
			const { transformedCharacter, transformedCharacterStats } = await applyCharacterChange(
				changedInto,
				$state.snapshot(storyState.value),
				$state.snapshot(characterState.value),
				$state.snapshot(characterStatsState.value),
				characterAgent,
				characterStatsAgent
			);

			const oldName = $state.snapshot(characterState.value.name);
			if (transformedCharacter) {
				characterState.value = transformedCharacter;
			}
			if (transformedCharacterStats) {
				characterStatsState.value = transformedCharacterStats;
			}
			//apply new resources
			playerCharactersGameState[characterState.value.name] = {
				...$state.snapshot(characterStatsState.value.resources),
				XP: playerCharactersGameState[oldName].XP
			};
			const { updatedGameActionsState, updatedPlayerCharactersGameState } = refillResourcesFully(
				$state.snapshot(characterStatsState.value.resources),
				$state.snapshot(characterState.value.name),
				$state.snapshot(gameActionsState.value),
				$state.snapshot(playerCharactersGameState)
			);
			gameActionsState.value = updatedGameActionsState;
			playerCharactersGameState = updatedPlayerCharactersGameState;
		}
		eventEvaluationState.value.character_changed.aiProcessingComplete = true;
		isAiGeneratingState = false;
	}
</script>

<div id="game-container" class="container mx-auto p-4">
	{#if isAiGeneratingState}
		<LoadingModal></LoadingModal>
	{/if}
	{#if errorState.userMessage}
		<ErrorDialog onclose={handleAIError} />
	{/if}
	{#if customActionImpossibleReasonState}
		<ImpossibleActionModal action={chosenActionState.value} onclose={handleImpossibleAction} />
	{/if}
	{#if gmQuestionState}
		<GMQuestionModal
			onclose={onGMQuestionClosed}
			question={gmQuestionState}
			{playerCharactersGameState}
		/>
	{/if}
	{#if showEventConfirmationDialog && !eventEvaluationState.value.character_changed?.aiProcessingComplete}
		<CharacterChangedConfirmationModal
			onclose={(confirmed) => confirmEvent(eventEvaluationState.value.character_changed, confirmed)}
			eventToConfirm={getEventToConfirm(eventEvaluationState.value.character_changed)}
		/>
	{/if}
	<UseSpellsAbilitiesModal
		bind:dialogRef={useSpellsAbilitiesModal}
		playerName={characterState.value.name}
		resources={playerCharactersGameState[characterState.value.name]}
		abilities={characterStatsState.value?.spells_and_abilities}
		storyImagePrompt={storyState.value.general_image_prompt}
		targets={currentGameActionState.currently_present_npcs}
		onclose={onTargetedSpellsOrAbility}
	></UseSpellsAbilitiesModal>
	<UseItemsModal
		bind:dialogRef={useItemsModal}
		{onDeleteItem}
		playerName={characterState.value.name}
		inventoryState={inventoryState.value}
		storyImagePrompt={storyState.value.general_image_prompt}
		onclose={onItemUseChosen}
	></UseItemsModal>
	{#if itemForSuggestActionsState}
		<SuggestedActionsModal
			onclose={onSuggestItemActionClosed}
			resources={playerCharactersGameState[characterState.value.name]}
			{itemForSuggestActionsState}
			{currentGameActionState}
		/>
	{/if}
	{#if levelUpState.value?.dialogOpened}
		<LevelUpModal onclose={onLevelUpModalClosed} />
	{/if}
	<DiceRollComponent
		bind:diceRollDialog
		action={chosenActionState.value}
		resetState={didAIProcessDiceRollActionState.value}
	></DiceRollComponent>
	<ResourcesComponent
		resources={playerCharactersGameState[characterState.value.name]}
		currentLevel={characterStatsState.value?.level}
	/>
	<div id="story" class="mt-4 justify-items-center rounded-lg bg-base-100 p-4 shadow-md">
		<!-- For proper updating, need to use gameActionsState.id as each block id -->
		{#each gameActionsState.value.slice(-3) as gameActionState (gameActionState.id)}
			<StoryProgressionWithImage
				story={gameActionState.story}
				imagePrompt="{gameActionState.image_prompt} {storyState.value.general_image_prompt}"
				gameUpdates={gameLogic
					.renderStatUpdates(
						$state.snapshot(gameActionState.stats_update),
						playerCharactersGameState[characterState.value.name],
						characterState.value.name
					)
					.concat(gameLogic.renderInventoryUpdate(gameActionState.inventory_update))}
			/>
			{#if gameActionState['fallbackUsed']}
				<small class="text-sm text-red-500"> For this action the fallback LLM was used.</small>
			{/if}
		{/each}
		{#if isGameEnded.value}
			<StoryProgressionWithImage story={gameLogic.getGameEndedMessage()} />
		{/if}
	</div>

	{#if !aiConfigState.value?.disableAudioState}
		<div class="mt-4 flex">
			<TTSComponent
				text={actionsTextForTTS}
				voice={ttsVoiceState.value}
				hidden={characterActionsState.value?.length === 0}
			></TTSComponent>
		</div>
	{/if}
	<div id="actions" bind:this={actionsDiv} class="mt-2 p-4 pb-0 pt-0"></div>
	{#if Object.keys(currentGameActionState).length !== 0}
		{#if !isGameEnded.value}
			{#if characterActionsState.value?.length === 0}
				<div class="flex flex-col">
					<span class="m-auto">Generating next actions...</span>
					<div class="m-auto">
						<LoadingIcon />
					</div>
				</div>
			{/if}
			<div id="static-actions" class="p-4 pb-0 pt-0">
				<button
					onclick={() =>
						sendAction({
							characterName: characterState.value.name,
							text: 'Continue The Tale'
						})}
					class="text-md btn btn-neutral mb-3 w-full"
				>Continue The Tale.
				</button>

				{#if levelUpState.value.buttonEnabled}
					<button
						onclick={() => {
							levelUpClicked(characterState.value.name);
						}}
						class="text-md btn btn-success mb-3 w-full"
					>Level up!
					</button>
				{/if}

				{#if !eventEvaluationState.value.character_changed?.aiProcessingComplete}
					<button
						onclick={() => {
							showEventConfirmationDialog = true;
						}}
						class="text-md btn btn-success mb-3 w-full"
					>Transform into {eventEvaluationState.value.character_changed?.changed_into}
					</button>
				{/if}
				<button
					onclick={() => {
						useSpellsAbilitiesModal.showModal();
					}}
					class="text-md btn btn-primary w-full"
				>Spells & Abilities
				</button>
				<button
					onclick={() => {
						useItemsModal.showModal();
					}}
					class="text-md btn btn-primary mt-3 w-full"
				>Inventory
				</button>
			</div>
		{/if}
		<form id="input-form" class="p-4 pb-2">
			<div class="w-full lg:join">
				<select bind:value={customActionReceiver} class="select select-bordered w-full lg:w-fit">
					<option selected>Character Action</option>
					<option>Game Command</option>
					<option>GM Question</option>
				</select>
				<input
					type="text"
					bind:this={customActionInput}
					class="input input-bordered w-full"
					id="user-input"
					placeholder={customActionReceiver === 'Character Action'
						? 'What do you want to do?'
						: customActionReceiver === 'GM Question'
							? 'Message to the Game Master'
							: 'Command without restrictions'}
				/>
				<button
					type="submit"
					onclick={onCustomActionSubmitted}
					class="btn btn-neutral w-full lg:w-1/4"
					id="submit-button"
				>Submit
				</button>
			</div>
		</form>
	{/if}

	<style>
      .btn {
          height: fit-content;
          padding: 1rem;
      }

      canvas {
          height: 100%;
          width: 100%;
      }
	</style>
</div>
