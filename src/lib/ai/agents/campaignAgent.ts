import { getRandomInteger, stringifyPretty } from '$lib/util.svelte';
import type { LLM, LLMMessage, LLMRequest } from '$lib/ai/llm';
import type { Action } from '$lib/ai/agents/gameAgent';
import type { CharacterDescription } from '$lib/ai/agents/characterAgent';
import isEqual from 'lodash.isequal';
import { exampleGameSystems, TROPES_CLICHE_PROMPT } from '$lib/ai/agents/storyAgent';

export type CampaignChapterPlotPoint = {
	plotId: number;
	objective: string;
	location: string;
	description: string;
	important_NPCs: Array<string>;
	steps: Array<string>;
	game_master_notes: Array<string>;
};

export type CampaignChapter = {
	chapterId: number;
	title: string;
	description: string;
	plot_points: Array<CampaignChapterPlotPoint>;
};
export type Campaign = {
	game: string;
	campaign_title: string;
	campaign_description: string;
	world_details: string;
	character_simple_description: string;
	chapters: Array<CampaignChapter>;
	general_image_prompt: string;
	theme: string;
	tonality: string;
};

export const getNewChapterObject = (chapterId: number) => {
	return {
		chapterId: chapterId,
		title: '',
		description: '',
		objective: '',
		plot_points: []
	};
};

export const getPromptForGameMasterNotes = (notes: Array<string>) => {
	if (!notes || notes.length === 0) {
		return '';
	}
	return '\nFollowing are Game Master Notes to consider for the next story progression:\n' +
		notes.join('\n') + '\n';
};

export const getNewPlotPointObject = (plotId) => {
	return {
		plotId: plotId,
		location: '',
		description: '',
		objective: '',
		important_NPCs: '',
		steps: ''
	};
};

const chaptersPrompt = `{
		"chapterId": number,
		"title": string,
		"description": string,
		"objective": string,
		"plot_points": [
			{
				"plotId": always start at 1 again for each new chapter,
				"location": string,
				"description": string,
				"objective": string,
				"important_NPCs": String Array; No object, just one descriptive String per NPC that are important to this plot point,
				"game_master_notes": string array; rules how specific obstacles must be solved by the player; e.g an enemy can only be damaged by fire; a specific spell is required to disarm a magical lock;
			},
			...
		]
	}`;

const jsonPrompt = `{
	"game": "Pick Any Pen & Paper System e.g. Pathfinder, Call of Cthulhu, Star Wars, Fate Core, World of Darkness, GURPS, Mutants & Masterminds, Dungeons & Dragons",
	"campaign_title": string,
	"campaign_description": string,
	"world_details": "Provide a vivid and in-depth description of the world's important details, including its geography, cultures, history, key events, technologies, political systems, and any unique elements that set it apart. Ensure the description creates an immersive setting that supports and enhances storytelling.",
	"character_simple_description": String; Generate a random character fitting the game system, world_details and campaignDescription, only provide a simple description and not every detail,
	"general_image_prompt": "Create a general system prompt max 10 words for this campaign to add to every image that is generated by an ai. Format: {visualStyle} {genre} {artistReference}",
	"theme": 'THEME of the story telling, e.g. world the story is located in',
	"tonality": 'TONALITY of the story telling, writing style, must fit GAME system',
	"chapters": [
		${chaptersPrompt},
		...
	]
}`;

export const initialCampaignState = {
	game: '',
	campaign_title: '',
	campaign_description: '',
	world_details: '',
	character_simple_description: '',
	chapters: [],
	general_image_prompt: '',
	theme: '',
	tonality: ''
};

const plotPointNumberPrompt = 'Each chapter with 2 - 4 plot points';
const mainAgent =
	'You are Pen & Paper campaign agent, crafting an epic, overarching campaign with chapters. Each chapter is an own adventure with an own climax and then fades gradually into the next chapter.\n' +
	'Design the Campaign to gradually increase the complexity of chapters as the players progress.\n' +
	'Include at least one major obstacle or antagonist in each chapter that ties into the overall campaign theme.\n' +
	"Provide a vivid and in-depth description of the world's important details, including its geography, cultures, history, key events, technologies, political systems, and any unique elements that set it apart.\n" +
	'Include important events, locations, NPCs and encounters that can adapt based on player choices, like alliances, moral dilemmas, or major battles.\n' +
	TROPES_CLICHE_PROMPT;

export class CampaignAgent {
	llm: LLM;

	constructor(llm: LLM) {
		this.llm = llm;
	}

	async generateCampaign(
		overwrites = {},
		characterDescription: CharacterDescription | undefined = undefined
	): Promise<Campaign> {
		const agent =
			mainAgent +
			'\nProvide 3 - 6 chapters.\n' +
			plotPointNumberPrompt +
			'\nAlways respond with following JSON!\n' +
			jsonPrompt;

		const preset: Partial<Campaign> = {
			...overwrites
		};
		if (isEqual(overwrites, {})) {
			preset.game = exampleGameSystems[getRandomInteger(0, exampleGameSystems.length - 1)];
		}
		const request: LLMRequest = {
			userMessage:
				'Create a new randomized campaign considering the following settings: ' +
				stringifyPretty(preset),
			historyMessages: [],
			systemInstruction: agent,
			temperature: 2
		};
		if (characterDescription?.name) {
			request.historyMessages?.push({
				role: 'user',
				content:
					'The campaign story must have the character_simple_description as player character protagonist: ' +
					stringifyPretty(characterDescription)
			});
		}
		const campaign = (await this.llm.generateReasoningContent(request))?.parsedObject as Campaign;
		return campaign;
	}

	async checkCampaignDeviations(
		nextAction: Action,
		plannedCampaign: Campaign,
		actionHistory: Array<LLMMessage>
	): Promise<any> {
		//careful as these are proxies, adding is fine
		const actionHistoryStoryOnly = actionHistory
			.filter((message) => message.role === 'model')
			.map((message) => ({ role: 'model', content: JSON.parse(message.content).story }));

		actionHistoryStoryOnly.push({ role: 'user', content: nextAction.text });
		const agent =
			'You are Pen & Paper campaign agent, crafting an epic, overarching campaign with chapters. Each chapter is an own adventure with an own climax and then fades gradually into the next chapter.\n' +
			'You will be given a plan for a campaign as plannedCampaign and how the actual campaign unfolded during the play session as actualCampaign.\n' +
			'Then you must decide if the actualCampaign has deviated too much from plannedCampaign and create a nudge that gently guides the character back to follow the chapter plot.\n' +
			'Do not micro manage every single plot point but only take care that the overall chapter and campaign stay on track.\n' +
			'Always respond with following JSON!\n' +
			`{
				"currentChapter": Identify the most relevant chapterId in plannedCampaign that the story aligns with; Explain your reasoning briefly; Format "{Reasoning} - CHAPTER_ID: {chapterId}",
				"currentPlotPoint": Identify the most relevant plotId in plannedCampaign that the story aligns with; Explain your reasoning briefly; Format "{Reasoning} - PLOT_ID: {plotId}",
  			"nextPlotPoint": Identify the next plotId in plannedCampaign, must be greater than currentPlotPoint or null if there is no next plot point; Format: "Reasoning why story is currently at this plotId - PLOT_ID: {plotId}",
  			"deviationExplanation": is the currentChapter still on track; if not include reasons why the actualCampaign deviated from currentChapter,
				"deviation": integer 0 - 100 how much the actualCampaign deviated from currentChapter,
				"pacingExplanation": reasoning on how quickly the characters are proceeding through the currentChapter,
				"pacing": integer 0 - 100 value increases/decreases depending on how quickly the characters are proceeding through the currentChapter,
				#only include plotNudge object if deviation > 50, else null
				"plotNudge": {
					"nudgeExplanation": Explain why the characters are guided back to follow the currentChapter plot,
					"nudgeStory": Create an NPC or event that gently guides the character back to follow the currentChapter plot. It must fit to the last character action.
				}
			}`;

		const request: LLMRequest = {
			userMessage: 'Check if the actualCampaign is on course with the plannedCampaign.',
			historyMessages: [
				{
					role: 'user',
					content: 'plannedCampaign: ' + stringifyPretty(plannedCampaign)
				},
				{
					role: 'user',
					content: 'actualCampaign: ' + stringifyPretty(actionHistoryStoryOnly)
				}
			],
			systemInstruction: agent
		};
		return (await this.llm.generateReasoningContent(request))?.parsedObject as Campaign;
	}

	async generateSingleChapter(
		campaignState: Campaign,
		characterState: CharacterDescription,
		chapterNumberToGenerate: number,
		chapter: CampaignChapter
	): Promise<CampaignChapter> {
		const agentInstruction = [mainAgent, plotPointNumberPrompt];
		if (chapter) {
			agentInstruction.push(
				'Important instruction! The new chapter must be based on the following: ' +
					stringifyPretty(chapter)
			);
		}
		agentInstruction.push(
			'The new chapter must fit within the other chapters, generate a chapter with chapterId: ' +
				chapterNumberToGenerate
		);
		agentInstruction.push('Always respond with following JSON!\n' + chaptersPrompt);

		let userMessage = 'Generate the new chapter.';
		if (chapter) {
			userMessage +=
				' Important! The new chapter must be based on the following:\n' + stringifyPretty(chapter);
		}
		const request: LLMRequest = {
			userMessage,
			historyMessages: [
				{
					role: 'user',
					content: 'Description of the campaign: ' + stringifyPretty(campaignState)
				}
			],
			systemInstruction: agentInstruction
		};
		if (characterState?.name) {
			request.historyMessages?.push({
				role: 'user',
				content: 'Description of the character: ' + stringifyPretty(characterState)
			});
		}
		return (await this.llm.generateReasoningContent(request))?.parsedObject as CampaignChapter;
	}
}
